http://www.informatika.bg/lectures/STL

I. pair<K, T>
#include <utility>
bool operator<(...), operator==(...) const-> първо се сравняват първите елементи от двете двойки, а ако те са еднакви се сравняват вторите.
pair<K, T> make_pair(K val1, T val2)
.first
.second

II. vector <T>
#include <vector>
[int idx] - връща елемента на позиция idx, все едно ползвате обикновен масив. Сложност O(1)
.at(int idx) - друг начин за вземане на елемента на позиция idx. Сложност O(1)
.front() - връща първия елемент от вектора. Сложност O(1)
.back() - връща последния елемент от вектора. Сложност O(1)
.push_back(T val) - добавя нов елемент със стойност val в края на вектора. Сложност O(1)
.pop_back() - премахва последния елемент на вектора. Сложност O(1)
.insert(iterator pos, T val) - добавя елемента val на позиция pos, измествайки елементите от pos нататък надясно. Сложност O(N)
.resize(int len) - увеличава или намалява размера на вектора до len. Сложност O(len)
.resize(int len, T val) - увеличава или намалява размера на вектора до len, като ако го увеличава, новите елементи са със стойност val. Сложност O(len)
.clear() - изтрива всички елементи от вектора. Сложност O(N)
.erase(iterator pos) - изтрива елемента на позицията, сочена от pos, измествайки елементите от pos нататък наляво. Сложност O(N)
.erase(iterator begin, iterator end) - изтрива всички елементи в интервала [begin, end), измествайки елементите от end нататък наляво. Сложност O(N)
.size() - връща колко елемента има в масива. Сложност O(1)
.empty() - връща true или false в зависимост дали .size() == 0. Сложност O(1)
.begin() - връща итератор към началото на елементите. Сложност O(1)
.end() - връща итератор към края на елементите. Сложност O(1)
.rbegin() - връща обратен итератор към началото на елементите. Сложност O(1)
.rend() - връща обратен итератор към края на елементите. Сложност O(1)

III. string
#include <string>

bool operator<(), operator==()
[int idx] - връща символа на позиция idx, все едно ползвате обикновен масив. Сложност O(1)
.at(int idx) - връща символа на позиция idx. Сложност O(1)
.find(char symbol) - връща първата позиция (индексирано от нула), на която се среща символът symbol. Ако символът не се среща в стринга, вместо това бива върната константата string::npos, която е число, по-голямо или равно на дължината на стринга или -1.
.find(string str) - връща първата позиция (индексирано от нула), на която се среща стрингът str. Ако аргументът не се среща в стринга, вместо това бива върната константата string::npos, която е число, по-голямо или равно на дължината на стринга или -1.
.substr(int start) - връща друг стринг, започващ от start-ия елемент на стринга. Сложност O(N - start)
.substr(int start, int len) - връща друг стринг, започващ от start-ия елемент на стринга с дължина len. Сложност O(len)
.c_str() - връща константен указател към C-string (терминиран с 0 char масив), със същото съдържание като стринга. Сложност O(N) (понякога и по-бързо)
.push_back(char val) - добавя нов символ в края на стринга. Сложност O(1)
.append(string str) - закача str накрая на стринга. Сложност O(M), където M е дължината на str
operator +=(string str) - същото като .append(). Сложност O(M), където M е дължината на str
.insert(iterator pos, string str) - добавя стринга str на позиция pos, измествайки символите от pos нататък надясно. Сложност O(N)
.resize(int len) - увеличава или намалява размера на стринга до len. Сложност O(len)
.resize(int len, char val) - увеличава или намалява размера на стринга до len, като ако го увеличава, новите елементи са със стойност val. Сложност O(len)
.clear() - изтрива всички символи от стринга. Сложност O(N)
.erase(iterator pos) - изтрива символа на позицията, сочена от pos, измествайки следващите символи наляво. Сложност O(N)
.erase(iterator begin, iterator end) - изтрива подстринга в интервала [begin, end), измествайки символите от end нататък наляво. Сложност O(N)
.size() - връща колко елемента има в масива. Сложност O(1)
.length() - същото като .size(). Сложност O(1)
.empty() - връща true или false в зависимост дали .size() == 0. Сложност O(1)
.begin() - връща итератор към началото на стринга. Сложност O(1)
.end() - връща итератор към края на стринга. Сложност O(1)

IV. deque - опашка, в която можем да добавяме и премахваме елементи както в началото, така и в края
#include <queue>

[int idx] - връща елемента на позиция idx. Сложност O(1)
.at(int idx) - друг начин, за вземане на елемента на позиция idx. Сложност O(1)
.front() - връща елемента в началото на опашката. Сложност O(1)
.back() - връща елемента в края на опашката. Сложност O(1)
.push_front(T val) - добавя нов елемент със стойност val в началото на опашката. Сложност O(1)
.push_back(T val) - добавя нов елемент със стойност val в края на опашката. Сложност O(1)
.pop_front() - премахва елемент от началото на опашката. Сложност O(1)
.pop_back() - премахва елемент от края на опашката. Сложност O(1)
.resize(int len) - увеличава или намалява размера на опашката до len. Ако се налага да се премахват елементи, това става от края на опашката. Сложност O(len)
.resize(int len, T val) - увеличава или намалява размера на опашката до len, като ако го увеличава, новите елементи са със стойност val. Сложност O(len)
.clear() - изтрива всички елементи от опашката. Сложност O(N)
.size() - връща колко елемента има в опашката. Сложност O(1)
.empty() - връща true или false в зависимост дали опашката е празна. Сложност O(1)
.begin() - връща итератор към началото на елементите. Сложност O(1)
.end() - връща итератор към края на елементите. Сложност O(1)

V. stack
#include <stack>

.top() - връща елемента на върха на стека без да го премахва. Сложност O(1)
.push(T val) - добавя нов елемент със стойност val на върха на стека. Сложност O(1)
.pop() - премахва елемента, намиращ се на върха на стека. Сложност O(1)
.size() - връща колко елемента има в стека. Сложност O(1)
.empty() - връща true или false в зависимост дали стекът е празен или не. Сложност O(1)

VI. queue
#include <queue>

.front() - връща елемента в началото на опашката без да го премахва. Сложност O(1)
.back() - връща елемента в края на опашката без да го премахва. Сложност O(1)
.push(T val) - добавя нов елемент със стойност val в края на опашката. Сложност O(1)
.pop() - премахва елемента, намиращ се в началото на опашката. Сложност O(1)
.size() - връща колко елемента има в опашката. Сложност O(1)
.empty() - връща true или false в зависимост дали опашката е празна или не. Сложност O(1)

VII. priority_queue
#include <queue>

.top() - връща максималният елемент от приоритетната опашка без да го премахва. Сложност O(1)
.push(T val) - добавя нов елемент със стойност val в приоритетната опашка. Сложност O(log(N))
.pop() - премахва максималния елемент от приоритетната опашка. Сложност O(log(N))
.size() - връща колко елемента има в приоритетната опашка. Сложност O(1)
.empty() - връща true или false в зависимост дали приоритетната опашка е празна или не. Сложност O(1)

VIII. set
#include <set>

.find(T val) - връща итератор към елемента със стойност val, или итератора .end(), ако елементът не се намира в множеството. Сложност O(log(N))
.count(T val) - намира колко на брой елемента със стойност val има в множеството. Тъй като това е множество, а не мултимножество, този брой е винаги или 0, или 1. Сложност O(log(N))
.lower_bound(T val) - връща итератор към първия елемент от множеството, който е по-голям или равен на val. Сложност O(log(N))
.upper_bound(T val) - връща итератор към първия елемент от множеството, който е по-голям от val. Сложност O(log(N))
.insert(T val) - добавя елемент със стойност val, ако такъв вече не съществува. Сложност O(log(N))
.clear() - изтрива всички елементи от множеството. Сложност O(N)
.erase(T val) - изтрива елемента със стойност val, ако такъв съществува. Сложност O(log(N))
.erase(iterator it) - изтрива елемента, сочен от итератора it. Сложност O(log(N))
.erase(iterator begin, iterator end) - изтрива всички елементи, в интервал, зададен от два итератора. Забележете, че интервалът е полу-затворен: [it1, it2). Сложност O(М), където M е броят изтрити елементи
.size() - връща колко елемента има в множеството. Сложност O(1)
.empty() - връща true или false в зависимост дали .size() == 0. Сложност O(1)
.begin() - връща итератор към началото на елементите. Сложност O(1)
.end() - връща итератор към края на елементите. Сложност O(1)

Ако искате да позволите съществуването на дубликатни стойности, можете да ползвате почти аналогичния multiset.

IX. map - асоциативен масив, тоест масив от двойки <key, value>, като по даден ключ (key) ви връща стойност (value)
#include <map>

[K key] - връща стойността, съответстваща на ключа key. Ако такава стойност няма, то не е дефинирано какво точно се случва, затова винаги, когато не сте абсолютно сигурни, че елемент с даден ключ присъства в асоциативния масив, проверявайте с .count(key) или .find(key) != .end() дали това е така. Това е и стандартният начин да присвоявате стойности - например q[“Alexander”] = 42; (където q е асоциативен масив от тип <string, int>) би присвоило стойност 42 на елемента с ключ "Alexander", или би създало такъв, ако все още не съществува. Сложност O(log(N))
.find(T val) - връща итератор към елемента с ключ val, или итератора .end(), ако няма елемент с такъв ключ. Сложност O(log(N))
.count(T val) - намира колко на брой елемента с ключ val има в асоциативния масив. Тъй като не са разрешени повтарящи се ключове, този брой е винаги или 0, или 1. Сложност O(log(N))
.lower_bound(T val) - връща итератор към първия елемент от асоциативния масив, чиито ключ е по-голям или равен на val. Сложност O(log(N))
.upper_bound(T val) - връща итератор към първия елемент от асоциативния масив, който е по-голям от val. Сложност O(log(N))
.insert(pair<K key, T val>) - добавя елемент с ключ key и стойност val, ако не съществува елемент с такъв ключ. Ако такъв елемент вече съществува, то стойността му бива променена на val. Сложност O(log(N))
.clear() - изтрива всички елементи от асоциативния масив. Сложност O(N)
.erase(T val) - изтрива елемента с ключ val, ако такъв съществува. Сложност O(log(N))
.erase(iterator it) - изтрива елемента, сочен от итератора it. Сложност O(log(N))
.erase(iterator begin, iterator end) - изтрива всички елементи, в интервал, зададен от два итератора. Забележете, че интервалът е полу-затворен: [it1, it2). Сложност O(М), където M е броят изтрити елементи
.size() - връща колко елемента има в множеството. Сложност O(1)
.empty() - връща true или false в зависимост дали .size() == 0. Сложност O(1)
.begin() - връща итератор към началото на елементите. Сложност O(1)
.end() - връща итератор към края на елементите. Сложност O(1)

Ако искате да позволите съществуването на дубликатни стойности, можете да ползвате почти аналогичния multimap.

X. Итериране на set и map

void printElementsOfSet(set <int> s) {
    for (set <int> :: iterator it = s.begin(); it != s.end(); it++)
        fprintf(stdout, "%d\n", *it);
}

void printElementsOfMap(map <double, int> m) {
    for (map <double, int> :: iterator it = m.begin(); it != m.end(); it++)
        fprintf(stdout, "(%lf, %d)\n", it->first, it->second);
}

XI. list
#include <list>

.front() - access the first element 
.back() - access the last element 
.begin()
.end()
.empty() - checks whether the container is empty 
.size() - returns the number of elements 
.clear() - clears the contents 
.insert(iterator pos, InputIt first, InputIt last)
.insert(iterator pos, const T& val)
.erase( iterator pos );
.erase( iterator first, iterator last );
.push_back(const T& val)
.pop_back()
.push_front(const T& val)
.pop_front() 

XII. Algorithms
#include <algorithm>
min(T a, T b);
max(T a, T b);
swap(T a, T b);
sort(итератор_към_началото, итератор_към_края);
stable_sort(итератор_към_началото, итератор_към_края);
reverse(итератор_към_началото, итератор_към_края);
random_shuffle(итератор_към_началото, итератор_към_края);
bool next_permutation(итератор_към_началото, итератор_към_края); - Преподрежда елементите в интервала в следващата лексикографска пермутация. Например след извикване върху (4, 1, 3, 2) ще получим (4, 2, 1, 3). Връща false, ако текущата пермутация е последната възможна.
void nth_element(итератор_към_началото, итератор_към_позицията, итератор_към_края); - Слага на дадена позиция елемента, който би бил на тази позиция ако целият масив е сортиран. Полезно е най-често за намиране на медиана. Времето за работа в средния случай е O(N).
bool binary_search(итератор_към_началото, итератор_към_края);
InputIterator find (InputIterator first, InputIterator last, const T& val);

#include <cstring>
memset(arr, -1, sizeof(arr));
memset(arr, 0, sizeof(arr));
memset(arr, 63, sizeof(arr)); inf
memset(arr,127, sizeof(arr)); inf
memset(arr, 128, sizeof(arr)); -inf